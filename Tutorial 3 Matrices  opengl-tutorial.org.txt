第三课：矩阵
齐次坐标
变换矩阵
	矩阵简介
	平移矩阵
	单位矩阵
	缩放矩阵
	旋转矩阵
	复合变换
模型（Model）、视图（View）和投影（Projection）矩阵
	模型矩阵
	视图矩阵
	投影矩阵
	复合变换：模型视图投影（MVP）矩阵
总结
练习

引擎根本不是在推着飞船动，而是让飞船保持静止，推着宇宙动。——《飞出个未来》(一部美国科幻动画片)

这一课是所有课程中最重要的一课。至少得看八遍。

齐次坐标
目前为止，我们仍然把3D顶点视为三元数(x, y, z)。现在引入一个新的分量w，得到向量(x, y, z, w)。
马上你就会明白这一点，现在只管记住以下两点：
	若w==1，则向量(x, y, z, 1)为空间中的点。
	若w==0，则向量(x, y, z, 0)为方向。
（请将此牢记在心。）

二者有什么不同呢？对于旋转，二者没什么不同。旋转一个点和一个方向，所得结果一样。但对于平移（将点沿着某个方向移动），情况就大不相同了。”移动一个方向“是毫无意义的。

齐次坐标可以让我们用同一个数学方程对点和方向作运算。

变换矩阵
矩阵简介
简而言之，矩阵就是一组纵横排列的数字。举个例子，一个2x3矩阵看起来像这样：

3D图形学中我们只采用4x4矩阵。我们可以用4x4矩阵对(x, y, z, w)顶点作变换。这一变换可以用矩阵乘顶点来实现：

矩阵x顶点（记住顺序！！矩阵左乘顶点，顶点用列向量表示）= 变换后的顶点

看上去复杂无比，实则不然。左手指着a，右手指着x。得到ax。左手移向下一个数b，右手也移向下一个数y。得到by。依次类推，得到cz、dw。最后求和ax + by + cz + dw，就得到了新的x！每一行都这么算下去，就得到了新的(x, y, z, w)向量。

这种频繁的、无聊的计算就让计算机代劳吧。

用C++，GLM表示：

用GLSL表示：

（还没复制粘贴代码吧？赶紧的，试一试吧）

平移矩阵
平移矩阵是最简单易懂的变换矩阵。平移矩阵是这样的：

其中，X、Y、Z是点的位移增量。
例如，若想把向量(10, 10, 10, 1)沿X轴方向平移10个单位，可得：

（动手算！！一定要动手算！）

这样就得到了齐次向量(20, 10, 10, 1)！记住，末尾的1代表这是一个点，而不是方向。经过变换计算后，点仍然是点，正合我意。

下面来看看，对一个代表Y轴负方向的向量作上述平移变换会得到什么结果：

也就是说，最后得到的还是原来那个方向(0, 0, -1, 0)，这正好印证了前面的结论：”移动一个方向是毫无意义的“。

那怎么用代码表示平移变换呢？
用C++，GLM表示：

用GLSL表示：呃，实际中我们一般不用GLSL计算平移变换。大多数情况下在C++代码中用glm::translate()计算矩阵，然后把这个矩阵传给GLSL。在GLSL中只做一次乘法：

单位矩阵
单位矩阵很特殊，它什么也不做。但它和普通代数中的1一样重要。代数中，Ax1.0 = A。单位矩阵与此类似。

用C++表示：

缩放矩阵
缩放矩阵也很简单：
例如把一个向量（点或方向皆可）沿各方向放大2倍：
w还是没变。你也许会问：”放缩一个向量“有什么用？嗯，大多数情况下是没什么用，所以一般不会去缩放向量。但在某些非常情况下，缩放向量就派得上用场了。（顺便说一下，单位矩阵只是缩放矩阵的一个特例，其(X, Y, Z) = (1, 1, 1)。单位矩阵同时也是旋转矩阵的一个特例，其(X, Y, Z)=(0, 0, 0)）。

用C++表示：

旋转矩阵
旋转矩阵比较复杂。这里先略过细节，毕竟平常应用中不必知道这些。想了解更多，请看”矩阵和四元数常见问题“（这个资源很火，应该有中文版吧）。

用C++表示：

复合变换
前面已经学习了如何旋转、平移和缩放向量。要是能将这些变换组合起来就更好了。只需把这些矩阵相乘即可，例如：

！！！千万注意！！！这行代码最先执行缩放，接着是旋转，最后才是平移。这就是矩阵乘法的工作方式。

变换的顺序不同，得出的结果也不同。体验一下：
- 向前一步（小心别磕着爱机）然后左转；
- 左转，然后向前一步

实际上，上述变换顺序正是你在控制游戏人物或者其他物体时所需的：先缩放；再调整方向；再平移。举个例子，假设有个船的模型（为简化论述略去旋转）：
	错误的做法：
		- 平移船体，移动量为(10, 0, 0)。船体中心目前位于离原点10个单位的地方。
		- 将船体放大到原来的2倍。每个坐标都扩大到了原来的2倍。
		这下离预定目标差得远了……最后你得到一艘很大的船，中心位于2*10=20。这可不是你想要的结果。

	正确的做法：
		- 将船体放大到原来的2倍，得到一艘中心位于原点的大船。
		- 平移船体。船大小不变，移动距离也正确。

矩阵-矩阵乘法和矩阵-向量乘法类似，所以这里也会省略一些细节，不清楚的请移步”矩阵和四元数常见问题“。现在，就让计算机来做这些计算：

用C++，GLM表示：

用GLSL表示：

模型、视图和投影矩阵

在接下来的课程中，假定大家都会绘制Blender经典3D模型：小猴Suzanne。

利用模型、视图和投影矩阵可以将变换过程清晰地分解为三个阶段。这些知识你也许用不上（我们在前两课不就没用么），但必需得有所了解。这一系列矩阵把整个流程划分得很清楚，已广为采用。

模型矩阵
这个3D模型和我们心爱的红色三角形一样，是由一组顶点定义的。这些顶点的XYZ坐标都是相对于物体中心的。也就是说，若顶点位于(0, 0, 0)，则它就在物体的中心。

玩家想用键鼠控制它，我们得移动这个模型。这简单，只需：放缩*旋转*平移就行了。在每一帧中用算出的这个矩阵去乘所有的顶点（用GLSL做矩阵-向量乘法，不要用C++！），物体就动起来了。唯一不动的就是世界坐标系（World Space）的中心。

这样，物体所有顶点就位于世界坐标系了。下图中黑色箭头的意思是：从模型坐标系（Model Space）（所有顶点都相对于模型的中心来定义）变换到世界坐标系（所有顶点都相对于世界坐标系中心来定义）。

下图概括了这一过程：

视图矩阵
这里再引述一下《飞出个未来》里的台词：

引擎根本不是在推着飞船动，而是让飞船保持静止，推着宇宙动。

仔细想想，摄像机的原理也是相通的。如果想换个角度观察一座山，你可以移动相机也可以移动山。当然现实生活中不可能去移山，但在计算机图形学中却十分方便。

起初，摄像机位于世界坐标系的原点。要移动世界只需再乘一个矩阵。打个比方，你想把摄像机沿X轴正方向移动3个单位。这和把整个世界（包括网格）往左（沿X轴负方向）移3个单位是等效的！脑子乱了吧？来写代码：

如下图所示：从世界坐标系（所有顶点都相对于世界坐标系中心来定义）变换到观察坐标系（Camera Space）（所有顶点都相对于摄像机来定义）。

在你脑袋撑爆之前，来欣赏一下GLM伟大的glm::LookAt函数：

下图解释了上述变换过程：

还没完呢。

投影矩阵
现在，我们处于观察坐标系中。这意味着，经历了这么多变换，点(0, 0)应该被画在屏幕的中心。但仅有x、y坐标还不足以确定物体在屏幕上的位置：还要考虑物体与摄像机的距离（z）！两个点x、y坐标相同，z值较大的点将会最终显示在屏幕上。

这就是所谓的透视投影（perspective projection）：

好在用一个4x4矩阵就能表示这个投影【附注1】：

最后一个变换：
从观察坐标系（所有顶点都相对于摄像机来定义）变换到齐次坐标系（Homogeneous Space ）（所有顶点都定义在一个小立方体中。立方体内的物体都会显示在屏幕上）。

最后一幅图示：

再添几张图，以便大家更好地理解投影变换。在投影之前，蓝色物体都位于观察坐标系中，红色的形体代表摄像机的视域四棱锥（frustum）：这是摄像机实际能看见的区域。

用投影矩阵去乘前面计算得到的矩阵，得到如下效果：

此图中，视域四棱锥变成了一个正方体（各轴上坐标范围都是-1到1，看上去不太清楚），所有的蓝色物体都经过了相同的形变。因此，离摄像机近的物体就显得大一些，远的显得小一些。和真实生活中一样！

让我们从视域四棱锥的”后面“看看它们的模样：

这就是你得出的图像了！看上去太方方正正了，因此，还需要做一次数学变换使之适合实际的窗口大小。

这就是实际绘制的图像啦！

复合变换：模型视图投影矩阵（MVP）

再来一串你钟爱的矩阵乘法：

总结
第一步：创建MVP矩阵。这一步必须在绘制模型前完成。

第二步：把MVP矩阵传给GLSL

第三步：在GLSL中用MVP变换顶点

完成！三角形还和第二课的一样，仍然在原点(0, 0, 0)，但是从点(4, 3, 3)透视观察的，朝上向量(0, 1, 0)，视场角（field of view）45°。

第6课中你会学到怎样用键鼠动态修改这些值，从而创建一个和游戏中类似的摄像机。但先得学会给3D模型上色（第4课）、贴纹理（第5课）。

练习
试着换掉glm::perspective
不用透视投影，试试正投影（orthographic projection ）（glm::ortho）
把模型矩阵改成平移-旋转-放缩的顺序，发现什么变化了没？如果想对一个人作变换，你觉得什么顺序最好呢？

附注

1：[...]好在用一个4x4矩阵就能表示这个投影：实际上，这句话并不对。透视变换并非仿射变换（affine transformation）。因此，透视投影无法完全由一个矩阵表示。在与投影矩阵相乘之后，齐次坐标系做了透视除法（每个分量都除以W）。W分量恰好是-Z（投影矩阵生来如此）。就这样，远处的点除以了较大的Z值，其X、Y坐标变得更小，点与点之间更紧密，物体看起来更小，这才产生了透视效果。